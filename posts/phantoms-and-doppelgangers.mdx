---
title: Defeating Phantoms & Doppelgangers
description: Explore the supernatural world of Javascript dependency management
date: 2021-02-05
image: phantoms-and-doppelgangers.png
---
<!-- 
- Introduction
- eIn this blog post we're going to discuss two phenomena around the world of Javascript dependency management. I'll discuss why these situations occur, the potential problems that result and how we can curcumvent them.
- Some funny warning about it not being for the faint-hearted, includes explicit diagrams of Directed Acyclic Graphs
 -->
Hello again, welcome to this post about two phenomena in the world of Javascript dependency management: Phantoms and NPM Doppelgangers. In this post, I'm going to define both concepts, talk about the problems that can result and how we can circumvent them.

_Warning: if you suffer from phobias of graphs, filesystems or dependency management then stop reading now._

## TL;DR
<!-- 
- A “phantom dependency” occurs when a project uses a package that is not defined in its package.json file
- A "NPM doopelganger" occurs when the `node_modules` directory structure is forced to contain duplicates of the same package
- Both of these issues are consequences of how the Node module resolution algorithm works and how package managers layout their `node_module` folder
 -->
If for whatever reason you are in a rush, this is a brief overview of the post.

A phantom dependency occurs when a project uses a package which isn't defined within the project's `package.json` file.

When a `node_modules` directory contains multiple copies of the same package, these packages are called NPM doppelgangers.

These are the consequences of two design decisions: How Node `require` algorithm works and how package managers lay out their `node_modules` directory.

If this sounds interesting (and Grammarly told me that it does), then read on for the in-depth explanations.

## Prequel

<!-- - Define graphs, directed graphs and DAGs -->
We first need to understand some basics around graph data structures and filesystems.

Graph definitions:
- A graph is a collection of nodes and edges
- A directed graph is a graph where the edges have a direction
- A directed acyclic graph (DAG) is a directed graph with no cycles

![Graph examples](/images/phantoms/graphs.png)

Packages can depend on other packages. In Javascript, we do this with `dependencies` and `devDependencies` in the project's `package.json`. This creates a dependency graph, where nodes are packages and edges are the "depends-on" relationship.

![Example dependency graph](/images/phantoms/dependency-graph.png)

Package managers need to fetch dependencies and store them on disk. It is responsible for the layout of the `node_modules` directory, it must be structured [so that Node can resolve imports](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders) from within the code.

Here's a valid layout for the example above:
```
.
└── project/
    ├── node_modules/
    │   └── a/
    │       └── node_modules/
    │           ├── b/
    │           │   └── node_modules/
    │           │       └── d 👎
    │           └── c/
    │               └── node_modules/
    │                   ├── d 👎
    │                   └── e
    └── package.json
```

The problem with this structure is that `d` is duplicated. This is a simplified example, and in a real project, the problem would be much more exaggerated.

Node has a special resolution rule that lets packages resolve dependencies that are direct children of the package's parent directory. Let's explore this with another example layout:

```
.
└── project/
    ├── node_modules/
    │   └── a/
    │       └── node_modules/ 😎
    │           ├── b
    │           ├── c/
    │           │   └── node_modules/
    │           │       └── e
    │           └── d
    └── package.json
```

For `b`, the `node_modules` marked with 😎 is the parent directory. The new rule says that all children of 😎 are resolvable by `b`, this includes `c` and `d`. Hooray, we've removed the duplication! [Don't raise your glass too soon](https://youtu.be/kQpgHOXxQoY?t=596).

One thing to note is that there is not a single unique way of structuring the `node_modules` directory. We've seen 2 valid approaches here, each with its own trade-offs. In practice, the final structure depends on the goals and heuristics used by the package manager.

## 👻 Phantoms

- Look at an example of phantom dependencies
- What can go wrong when you have phantom dependencies
- How can we avoid it? Is it possible with NPM or Yarn? How does Rush (and PNPM?) solve it?

## 👯 Doppelgangers

- Example
- What can go wrong
- How to avoid it? PNPM, not possible with NPM or Yarn

## You made it!

- You've survived this NPM horror movie
- We've seen how both of these issues can arise and what effects they might have
- Breifely talked about how newer tooling is helping to eliminate these issues
- If this was useful to you please share
- Include extra resources
- We'll see you in the sequel