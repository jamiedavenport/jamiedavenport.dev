---
title: Defeating Phantoms & Doppelgangers
description: Explore the supernatural world of Javascript dependency management
date: 2021-02-27
image: phantoms-and-doppelgangers.png
---

Hello again ðŸ‘‹ Welcome to this post about two phenomena in the world of Javascript dependency management: Phantoms and NPM Doppelgangers. In this post, I'm going to define both concepts, talk about the problems that can result and how we can circumvent them.

_Warning: if you suffer from phobias of graphs, filesystems or dependency management then stop reading now._

## TL;DR

A _phantom dependency_ occurs when a project uses a package that isn't defined within the project's `package.json` file.

When a `node_modules` directory contains multiple copies of the same package, these packages are called _NPM doppelgangers_.

These are consequences of design decisions made by Node and its package managers and so they don't necessarily apply to other languages.

## Graphs 101

Let's remind ourselves of some basic graph definitions.

- A _graph_ is a collection of nodes and edges
- A _directed graph_ is a graph where the edges have a direction
- A _directed acyclic graph (DAG)_ is a directed graph with no cycles

![Graph examples](/images/phantoms/graphs.png)

Most of the time your Javascript project will depend on some other libraries and frameworks. The "depends-on" relationship is expressed in our `package.json` file under the `dependencies` key.

```json
// package.json
{
  ...
  "dependencies": {
    "next": "^10.0.3",
    "react": "16.13.1",
    "react-dom": "16.13.1",
    "tailwindcss": "^2.0.1",
    ...
  },
  ...
}
```

Building a UI? Then you might have React and Next.js, those both also depend on a number of libraries. This produces a dependency graph, which itself is a DAG.

[Example]

## Node & package managers introduction

- Node made the design decision to represent the dependency graph on disk.
- Most package management solutions in other langauges don't do this and so they don't suffer the same problems.
- Your Node code can include another library using `require`. (Example)
- When executing code like this, Node looks in a number of places on the disk to locate the code based on its algorithm.
- One of these is the `node_modules` directory.

- Package managers such as NPM and Yarn have the job of fetching all the libraries needed for your project to run.
- It pulls them from the internet and stores them in a `node_modules` directory.
- It must be laid out in such a way that the Node `require` algorithm can find them.
- There is not necessarily a unique way of structuring any DAG (our depepndency graph) on disk.
- Package managers might structure the `node_modules` directory according to some of its own goals such as "Minimise duplication"

## Phantoms

> A phantom dependency occurs when a project uses a package that isn't defined within the project's package.json file.

- How? Example dependency structure that results in the problem.
- Look at a diamond dependency pattern.
- Can't represent this on disk. It's a tree structure. No way for subdirectories to join together.
- We would have to duplicate the dependency to get a structure like so (example).
- Node added a special rule, this lets packages resolve dependencies which are siblings.
- Now we can have the following structure and all the code will continue to work.
- However now that dependency becomes available for our project. The following code will work even though we haven't got the dep as an explicit `dependency`.

## Doppelgangers

> When a node_modules directory contains multiple copies of the same package, these packages are called NPM doppelgangers.

- How? Example dependency structure that results in the problem.
- Different versions of the same library.
- These are not sharable but the directory names would conflict.
- Only hoist one of them, resulting in the other being duplicated.

## PNPM

- The choice and design decisions of the package manager are to blame. Choose a different one.
- The issues with Phantoms and Doppelgangers can be very difficult to debug. Prevention is better than the cure in this case.
- PNPM downloads all dependencies to a central cache
- Then it recreates your project `node_modules` by creating symlinks to the actual dependencies.
- It creates a `node_modules` directory containing only your `package.json` dependencies
- These are symlinks to a central cache, which is structured in a way that allows dependencies between them.
- PNPM also has other benefits such as increased performance, I'd recommend [this article](https://www.kochan.io/nodejs/why-should-we-use-pnpm.html) to learn more about it's benefits and internals.

## Conclusion
