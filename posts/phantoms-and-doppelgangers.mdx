---
title: Defeating Phantoms & Doppelgangers
description: Explore the supernatural world of Javascript dependency management
date: 2021-02-05
image: phantoms-and-doppelgangers.png
---
<!-- 
- Introduction
- eIn this blog post we're going to discuss two phenomena around the world of Javascript dependency management. I'll discuss why these situations occur, the potential problems that result and how we can curcumvent them.
- Some funny warning about it not being for the faint-hearted, includes explicit diagrams of Directed Acyclic Graphs
 -->
Hello again, welcome to this post about two phenomena in the world of Javascript dependency management: Phantoms and NPM Doppelgangers. In this post, I'm going to define both concepts, talk about the problems that can result and how we can circumvent them.

_Warning: if you suffer from phobias of graphs, filesystems or dependency management then stop reading now._

## TL;DR
<!-- 
- A â€œphantom dependencyâ€ occurs when a project uses a package that is not defined in its package.json file
- A "NPM doopelganger" occurs when the `node_modules` directory structure is forced to contain duplicates of the same package
- Both of these issues are consequences of how the Node module resolution algorithm works and how package managers layout their `node_module` folder
 -->
If for whatever reason you are in a rush, this is a brief overview of the post.

A phantom dependency occurs when a project uses a package which isn't defined within the project's `package.json` file.

When a `node_modules` directory contains multiple copies of the same package, these packages are called NPM doppelgangers.

These are the consequences of two design decisions: How Node `require` algorithm works and how package managers lay out their `node_modules` directory.

If this sounds interesting (and Grammarly told me that it does), then read on for the in-depth explanations.

## Prequel

- Define dependency graphs as a DAG (with example)
- Discuss how package managers need to represent this DAG on disk (why? include diagrams)
- Mention that there is not a single unique way of doing this and different package managers use their own heuristics and goals to achieve it

## ðŸ‘» Phantoms

- Look at an example of phantom dependencies
- What can go wrong when you have phantom dependencies
- How can we avoid it? Is it possible with NPM or Yarn? How does Rush (and PNPM?) solve it?

## ðŸ‘¯ Doppelgangers

- Example
- What can go wrong
- How to avoid it? PNPM, not possible with NPM or Yarn

## You made it!

- You've survived this NPM horror movie
- We've seen how both of these issues can arise and what effects they might have
- Breifely talked about how newer tooling is helping to eliminate these issues
- If this was useful to you please share
- Include extra resources
- We'll see you in the sequel