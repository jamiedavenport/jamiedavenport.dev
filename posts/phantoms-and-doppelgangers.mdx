---
title: Defeating Phantoms & Doppelgangers
description: Explore the supernatural world of Javascript dependency management
date: 2021-02-26
image: phantoms-and-doppelgangers.png
---

Hello again ðŸ‘‹ Welcome to this post about two phenomena in the world of Javascript dependency management: Phantoms and NPM Doppelgangers. In this post, I'm going to define both concepts, talk about the problems that can result and how we can circumvent them.

_Warning: if you suffer from phobias of graphs, filesystems or dependency management then stop reading now._

## TL;DR

A _phantom dependency_ occurs when a project uses a package that isn't defined within the project's `package.json` file.

When a `node_modules` directory contains multiple copies of the same package, these packages are called _NPM doppelgangers_.

These are consequences of design decisions made by Node and its package managers and so they don't necessarily apply to other languages.

## Graphs 101

Let's remind ourselves of some basic graph definitions.

- A _graph_ is a collection of nodes and edges
- A _directed graph_ is a graph where the edges have a direction
- A _directed acyclic graph (DAG)_ is a directed graph with no cycles

![Graph examples](/images/phantoms/graphs.png)

Most of the time your Javascript project will depend on some other libraries and frameworks. The "depends-on" relationship is expressed in our `package.json` file under the `dependencies` key.

```json
// package.json
{
  ...
  "dependencies": {
    "next": "^10.0.3",
    "react": "16.13.1",
    "react-dom": "16.13.1",
    "tailwindcss": "^2.0.1",
    ...
  },
  ...
}
```

Building a UI? Then you might have React and Next.js, those both also depend on a number of libraries. This produces a dependency graph, which is a DAG.

![Dependency graph](/images/phantoms/dependency-graph.png)

## Node vs Package Managers

Node made a design decision to represent the dependency graph on disk. When loading in external libraries, Node looks in a number of directories according to its resolution algorithm. For example:

```javascript
// ~/projects/project/index.js

const a = require('a')

...
```

Node would search for `a` in the following locations (in order):

- `~/projects/project/node_modules/a`
- `~/projects/node_modules/a`
- `~/node_modules/a`

You can read the algorithm [pseudocode](https://nodejs.org/api/modules.html#modules_all_together) to understand exactly how it works.

_Note: Most languages and package management solutions don't do this and therefore they don't suffer from the same issues._

Package Managers, such as NPM and Yarn, fetches the libraries your project depends-on and puts the modules in place so that node can find them. This means that it must be structured according to the Node `require` algorithm.

However, there's not always a unique way of structuring a `node_modules` directory. This means that Package Managers are able to use their own goals and heuristics to achieve the desired result for example "miminise duplication" might be a goal.

## Phantoms

> A phantom dependency occurs when a project uses a package that isn't defined within the project's package.json file.

Let's look at a fairly simple and hopefully not too common way in which this can occur. Imagine you have installed React (or any library) globally using `npm install --global react`. Now every Node project on your machine can use it without first specifying the dependency in the `package.json`. This might work fine on your machine, but other developers and CI likely won't be happy. The solution to this is to avoid installing libraries globally.

Now, let's look at a more subtle example.

- Look at a diamond dependency pattern.
- Can't represent this on disk. It's a tree structure. No way for subdirectories to join together.
- We would have to duplicate the dependency to get a structure like so (example).
- Node added a special rule, this lets packages resolve dependencies which are siblings.
- Now we can have the following structure and all the code will continue to work.
- However now that dependency becomes available for our project. The following code will work even though we haven't got the dep as an explicit `dependency`.

## Doppelgangers

> When a node_modules directory contains multiple copies of the same package, these packages are called NPM doppelgangers.

- How? Example dependency structure that results in the problem.
- Different versions of the same library.
- These are not sharable but the directory names would conflict.
- Only hoist one of them, resulting in the other being duplicated.

## PNPM

- The choice and design decisions of the package manager are to blame. Choose a different one.
- The issues with Phantoms and Doppelgangers can be very difficult to debug. Prevention is better than the cure in this case.
- PNPM downloads all dependencies to a central cache
- Then it recreates your project `node_modules` by creating symlinks to the actual dependencies.
- It creates a `node_modules` directory containing only your `package.json` dependencies
- These are symlinks to a central cache, which is structured in a way that allows dependencies between them.
- PNPM also has other benefits such as increased performance, I'd recommend [this article](https://www.kochan.io/nodejs/why-should-we-use-pnpm.html) to learn more about it's benefits and internals.

## Conclusion
