---
title: Defeating Phantoms & Doppelgangers
description: Explore the supernatural world of Javascript dependency management
date: 2021-02-05
image: phantoms-and-doppelgangers.png
---
<!-- 
- Introduction
- eIn this blog post we're going to discuss two phenomena around the world of Javascript dependency management. I'll discuss why these situations occur, the potential problems that result and how we can curcumvent them.
- Some funny warning about it not being for the faint-hearted, includes explicit diagrams of Directed Acyclic Graphs
 -->
Hello again, welcome to this post about two phenomena in the world of Javascript dependency management: Phantoms and NPM Doppelgangers. In this post, I'm going to define both concepts, talk about the problems that can result and how we can circumvent them.

_Warning: if you suffer from phobias of graphs, filesystems or dependency management then stop reading now._

## TL;DR
<!-- 
- A “phantom dependency” occurs when a project uses a package that is not defined in its package.json file
- A "NPM doopelganger" occurs when the `node_modules` directory structure is forced to contain duplicates of the same package
- Both of these issues are consequences of how the Node module resolution algorithm works and how package managers layout their `node_module` folder
 -->
If for whatever reason you are in a rush, this is a brief overview of the post.

A phantom dependency occurs when a project uses a package which isn't defined within the project's `package.json` file.

When a `node_modules` directory contains multiple copies of the same package, these packages are called NPM doppelgangers.

These are the consequences of two design decisions: How Node `require` algorithm works and how package managers lay out their `node_modules` directory.

If this sounds interesting (and Grammarly told me that it does), then read on for the in-depth explanations.

## Prequel

<!-- - Define graphs, directed graphs and DAGs -->
We first need to understand some basics around graph data structures and filesystems.

Graph definitions:
- A graph is a collection of nodes and edges
- A directed graph is a graph where the edges have a direction
- A directed acyclic graph (DAG) is a directed graph with no cycles

![Graph examples](/images/phantoms/graphs.png)

Packages can depend on other packages. In Javascript, we do this with `dependencies` and `devDependencies` in the project's `package.json`. This creates a dependency graph, where nodes are packages and edges are the "depends-on" relationship.

![Example dependency graph](/images/phantoms/dependency-graph.png)

Package managers need to fetch dependencies and store them on disk. It is responsible for the layout of the `node_modules` directory, it must be structured [so that Node can resolve imports](https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders) from within the code.

Here's a valid layout for the example above:
```
.
└── project/
    ├── node_modules/
    │   ├── b/
    │   │   └── node_modules/
    │   │       └── d 👎
    │   └── c/
    │       └── node_modules/
    │           ├── d 👎
    │           └── e
    └── package.json
```

The problem with this structure is that `d` is duplicated. This is a simplified example, and in a real project, the problem would be much more exaggerated.

Node has a special resolution rule that lets packages resolve dependencies that are direct children of the package's parent directory. Let's explore this with another example layout:

```
.
└── project/
    ├── node_modules/
    │   ├── b
    │   ├── c/
    │   │   └── node_modules/
    │   │       └── e
    │   └── d
    └── package.json
```

For `b`, the `node_modules` marked with 😎 is the parent directory. The new rule says that all children of 😎 are resolvable by `b`, this includes `c` and `d`. Hooray, we've removed the duplication! [Don't raise your glass too soon](https://youtu.be/kQpgHOXxQoY?t=596).

Let's look at a real example of a `node_modules` directory, how about the one for this website? The `package.json` is [here](https://github.com/jamiedavenport/jamiedavenport.dev/blob/main/package.json) for reference and the resulting `node_modules` is shown below:

![jamiedavenport.dev node_modules directory](/images/phantoms/node-modules.png)

There's a lot more in there than is defined in the `package.json`, 741 packages to be specific. Yarn has flattened the directory to avoid the duplication we saw previously, these extra dependencies are the dependencies of my dependencies.

One thing to note is that there is not a single unique way of structuring the `node_modules` directory. We've seen 2 valid approaches here, each with its own trade-offs. In practice, the final structure depends on the goals and heuristics used by the package manager.

## 👻 Phantoms

> A phantom dependency occurs when a project uses a package which isn't defined within the project's `package.json` file.

Think back to our first example, it might have a `package.json` like so:

```json
{
  "name": "project",
  dependencies: {
    "b": "^1.0.0",
    "c": "^2.0.0"
  }
}
```

Imagine the directory structure (after installing dependencies) looks like this:

```
.
└── project/
    ├── node_modules/
    │   ├── b
    │   ├── c
    │   ├── e
    │   └── d
    ├── package.json
    └── bad-script.js
```

Finally, `bad-script.js` has the following contents:

```js
const d = require('d');
const e = require('e');

// Some code that uses these dependencies
```

Voila, `d` and `e` are both phantom dependencies. They do not exist in the `package.json` but the code is able to use them just fine!

I hope that this is setting off alarm bells in your head. Our code is able to use something that's directly out of our control.

Package `c` can drop it's dependency on `e` or even perform a major update of `e` and publish the new release as a patch. If you upgrade your dependencies, while respecting the version ranges in the `package.json`, then you could be in for a shock to find your code no longer works.

Furthermore, you can have phantom dependencies with `devDependencies` which exist on your machine during development but not in production. In the worst scenario, you won't hear about this until your package consumers or end users complain.

## 👯 Doppelgangers

- Example
- What can go wrong
- How to avoid it? PNPM, not possible with NPM or Yarn

## PNPM, the hero we need but don't deserve

- PNPM downloads all dependencies to a central cache
- Then it recreates your project `node_modules` by creating symlinks to the actual dependencies.
- It creates a `node_modules` directory containing only your `package.json` dependencies
- These are symlinks to a central cache, which is structured in a way that allows dependencies between them.
- PNPM also has other benefits such as increased performance, I'd recommend [this article](https://www.kochan.io/nodejs/why-should-we-use-pnpm.html) to learn more about it's benefits and internals.

## You made it!

- You've survived this NPM horror movie
- We've seen how both of these issues can arise and what effects they might have
- Breifely talked about how newer tooling is helping to eliminate these issues
- If this was useful to you please share
- Include extra resources
- We'll see you in the sequel